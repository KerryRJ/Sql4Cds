using System;
using System.Collections.Generic;
using System.Data.SqlTypes;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.XPath;
using MarkMpn.Sql4Cds.Engine.Visitors;
using Microsoft.Crm.Sdk.Messages;
using Microsoft.SqlServer.TransactSql.ScriptDom;
using Microsoft.Xrm.Sdk;
using Newtonsoft.Json.Linq;
using Wmhelp.XPath2;
using Wmhelp.XPath2.Extensions;

namespace MarkMpn.Sql4Cds.Engine.ExecutionPlan
{
    /// <summary>
    /// Converts ScriptDom expressions to compiled functions and checks the types of values that will be generated
    /// </summary>
    static class ExpressionExtensions
    {
        /// <summary>
        /// Gets the type of value that will be generated by an expression
        /// </summary>
        /// <param name="expr">The expression to get the type of</param>
        /// <param name="context">The context the expression is being compiled in</param>
        /// <param name="sqlType">The SQL data type that will be returned</param>
        /// <returns>The type of value that will be returned by the expression</returns>
        public static Type GetType(this TSqlFragment expr, ExpressionCompilationContext context, out DataTypeReference sqlType)
        {
            var contextParam = Expression.Parameter(typeof(ExpressionExecutionContext));
            var expression = ToExpression(expr, context, contextParam, out sqlType);
            return expression.Type;
        }

        /// <summary>
        /// Compiles an expression to a function
        /// </summary>
        /// <param name="expr">The expression to be compiled</param>
        /// <param name="context">The context the expression is being compiled in</param>
        /// <returns>A function that accepts an <see cref="ExpressionExecutionContext"/> representing the context the expression is being evaluated in and returns the value of the expression</returns>
        public static Func<ExpressionExecutionContext, object> Compile(this TSqlFragment expr, ExpressionCompilationContext context)
        {
            var contextParam = Expression.Parameter(typeof(ExpressionExecutionContext));
            var expression = ToExpression(expr, context, contextParam, out _);
            expression = Expr.Box(expression);

            return Expression.Lambda<Func<ExpressionExecutionContext, object>>(expression, contextParam).Compile();
        }

        /// <summary>
        /// Compiles a boolean expression to a function
        /// </summary>
        /// <param name="b">The expression to be compiled</param>
        /// <param name="context">The context the expression is being compiled in</param>
        /// <returns>A function that accepts aan <see cref="ExpressionExecutionContext"/> representing the context the expression is being evaluated in and returns the value of the expression</returns>
        public static Func<ExpressionExecutionContext, bool> Compile(this BooleanExpression b, ExpressionCompilationContext context)
        {
            var contextParam = Expression.Parameter(typeof(ExpressionExecutionContext));
            var expression = ToExpression(b, context, contextParam, out _);
            expression = Expression.IsTrue(expression);
            return Expression.Lambda<Func<ExpressionExecutionContext, bool>>(expression, contextParam).Compile();
        }

        private static Expression ToExpression(this TSqlFragment expr, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            Expression expression;

            if (expr is ColumnReferenceExpression col)
                expression = ToExpression(col, context, contextParam, out sqlType);
            else if (expr is IdentifierLiteral guid)
                expression = ToExpression(guid, context, contextParam, out sqlType);
            else if (expr is IntegerLiteral i)
                expression = ToExpression(i, context, contextParam, out sqlType);
            else if (expr is MoneyLiteral money)
                expression = ToExpression(money, context, contextParam, out sqlType);
            else if (expr is NullLiteral n)
                expression = ToExpression(n, context, contextParam, out sqlType);
            else if (expr is NumericLiteral num)
                expression = ToExpression(num, context, contextParam, out sqlType);
            else if (expr is RealLiteral real)
                expression = ToExpression(real, context, contextParam, out sqlType);
            else if (expr is StringLiteral str)
                expression = ToExpression(str, context, contextParam, out sqlType);
            else if (expr is OdbcLiteral odbc)
                expression = ToExpression(odbc, context, contextParam, out sqlType);
            else if (expr is BooleanBinaryExpression boolBin)
                expression = ToExpression(boolBin, context, contextParam, out sqlType);
            else if (expr is BooleanComparisonExpression cmp)
                expression = ToExpression(cmp, context, contextParam, out sqlType);
            else if (expr is BooleanParenthesisExpression boolParen)
                expression = ToExpression(boolParen, context, contextParam, out sqlType);
            else if (expr is InPredicate inPred)
                expression = ToExpression(inPred, context, contextParam, out sqlType);
            else if (expr is BooleanIsNullExpression isNull)
                expression = ToExpression(isNull, context, contextParam, out sqlType);
            else if (expr is LikePredicate like)
                expression = ToExpression(like, context, contextParam, out sqlType);
            else if (expr is BooleanNotExpression not)
                expression = ToExpression(not, context, contextParam, out sqlType);
            else if (expr is FullTextPredicate fullText)
                expression = ToExpression(fullText, context, contextParam, out sqlType);
            else if (expr is Microsoft.SqlServer.TransactSql.ScriptDom.BinaryExpression bin)
                expression = ToExpression(bin, context, contextParam, out sqlType);
            else if (expr is FunctionCall func)
                expression = ToExpression(func, context, contextParam, out sqlType);
            else if (expr is ParenthesisExpression paren)
                expression = ToExpression(paren, context, contextParam, out sqlType);
            else if (expr is Microsoft.SqlServer.TransactSql.ScriptDom.UnaryExpression unary)
                expression = ToExpression(unary, context, contextParam, out sqlType);
            else if (expr is VariableReference var)
                expression = ToExpression(var, context, contextParam, out sqlType);
            else if (expr is SimpleCaseExpression simpleCase)
                expression = ToExpression(simpleCase, context, contextParam, out sqlType);
            else if (expr is SearchedCaseExpression searchedCase)
                expression = ToExpression(searchedCase, context, contextParam, out sqlType);
            else if (expr is ConvertCall convert)
                expression = ToExpression(convert, context, contextParam, out sqlType);
            else if (expr is CastCall cast)
                expression = ToExpression(cast, context, contextParam, out sqlType);
            else if (expr is ParameterlessCall parameterless)
                expression = ToExpression(parameterless, context, contextParam, out sqlType);
            else if (expr is GlobalVariableExpression global)
                expression = ToExpression(global, context, contextParam, out sqlType);
            else if (expr is ExpressionCallTarget callTarget)
                expression = ToExpression(callTarget, context, contextParam, out sqlType);
            else if (expr is DistinctPredicate distinct)
                expression = ToExpression(distinct, context, contextParam, out sqlType);
            else
                throw new NotSupportedQueryFragmentException("Unhandled expression type", expr);

            if (expr is PrimaryExpression primary && primary.Collation != null)
            {
                if (!Collation.TryParse(primary.Collation.Value, out var coll))
                    throw new NotSupportedQueryFragmentException("Invalid collation", primary.Collation);

                if (expression.Type == typeof(SqlString) && sqlType is SqlDataTypeReferenceWithCollation sqlTypeWithCollation)
                {
                    expression = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), expression, Expression.Constant(coll));
                    sqlType = new SqlDataTypeReferenceWithCollation
                    {
                        SqlDataTypeOption = sqlTypeWithCollation.SqlDataTypeOption,
                        Collation = coll,
                        CollationLabel = CollationLabel.Explicit
                    };

                    foreach (var param in sqlTypeWithCollation.Parameters)
                        ((SqlDataTypeReferenceWithCollation)sqlType).Parameters.Add(param);
                }
            }

            return expression;
        }

        private static Expression ToExpression(ColumnReferenceExpression col, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            var name = col.GetColumnName();

            if (context.Schema == null || !context.Schema.ContainsColumn(name, out var normalizedName))
            {
                if (context.Schema == null || !context.Schema.Aliases.TryGetValue(name, out var normalized))
                {
                    if (context.NonAggregateSchema != null && context.NonAggregateSchema.ContainsColumn(name, out _))
                        throw new NotSupportedQueryFragmentException("Column is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause", col);

                    var ex = new NotSupportedQueryFragmentException("Unknown column", col);

                    if (col.MultiPartIdentifier.Identifiers.Count == 1 && col.MultiPartIdentifier.Identifiers[0].QuoteType == QuoteType.DoubleQuote)
                        ex.Suggestion = $"Did you mean '{name}'?";
                    else if (name.Equals("false", StringComparison.OrdinalIgnoreCase))
                        ex.Suggestion = "Did you mean '0'?";
                    else if (name.Equals("true", StringComparison.OrdinalIgnoreCase))
                        ex.Suggestion = "Did you mean '1'?";

                    throw ex;
                }

                throw new NotSupportedQueryFragmentException("Ambiguous column reference", col)
                {
                    Suggestion = $"Did you mean:\r\n{String.Join("\r\n", normalized.Select(c => $"* {c}"))}"
                };
            }

            sqlType = context.Schema.Schema[normalizedName].Type;
            var entity = Expression.Property(contextParam, nameof(ExpressionExecutionContext.Entity));
            var expr = Expression.Property(entity, typeof(Entity).GetCustomAttribute<DefaultMemberAttribute>().MemberName, Expression.Constant(normalizedName));
            return Expression.Convert(expr, sqlType.ToNetType(out _));
        }

        private static Expression ToExpression(IdentifierLiteral guid, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = DataTypeHelpers.UniqueIdentifier;
            return Expression.Constant(new SqlGuid(guid.Value));
        }

        private static Expression ToExpression(IntegerLiteral i, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = DataTypeHelpers.Int;
            return Expression.Constant(new SqlInt32(Int32.Parse(i.Value, CultureInfo.InvariantCulture)));
        }

        private static Expression ToExpression(MoneyLiteral money, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = DataTypeHelpers.Money;
            return Expression.Constant(new SqlMoney(Decimal.Parse(money.Value, CultureInfo.InvariantCulture)));
        }

        private static Expression ToExpression(NullLiteral n, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = DataTypeHelpers.ImplicitIntForNullLiteral;
            return Expression.Constant(SqlInt32.Null);
        }

        private static Expression ToExpression(NumericLiteral num, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            var value = new SqlDecimal(Decimal.Parse(num.Value, CultureInfo.InvariantCulture));
            sqlType = DataTypeHelpers.Decimal(value.Precision, value.Scale);
            return Expression.Constant(value);
        }

        private static Expression ToExpression(RealLiteral real, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = DataTypeHelpers.Real;
            return Expression.Constant(new SqlDouble(Double.Parse(real.Value, CultureInfo.InvariantCulture)));
        }

        private static Expression ToExpression(StringLiteral str, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = str.IsNational
                ? DataTypeHelpers.NVarChar(str.Value.Length, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault)
                : DataTypeHelpers.VarChar(str.Value.Length, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

            return Expression.Constant(context.PrimaryDataSource.DefaultCollation.ToSqlString(str.Value));
        }

        private static Expression ToExpression(OdbcLiteral odbc, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            switch (odbc.OdbcLiteralType)
            {
                case OdbcLiteralType.Date:
                    sqlType = DataTypeHelpers.Date;
                    return Expression.Constant(new SqlDateTime(DateTime.ParseExact(odbc.Value, "yyyy'-'MM'-'dd", CultureInfo.CurrentCulture, DateTimeStyles.None)));

                case OdbcLiteralType.Timestamp:
                    sqlType = DataTypeHelpers.DateTime;
                    return Expression.Constant(new SqlDateTime(DateTime.ParseExact(odbc.Value, "yyyy'-'MM'-'dd HH':'mm':'ss", CultureInfo.CurrentCulture, DateTimeStyles.None)));

                case OdbcLiteralType.Guid:
                    sqlType = DataTypeHelpers.UniqueIdentifier;
                    return Expression.Constant(new SqlGuid(odbc.Value));

                default:
                    throw new NotSupportedQueryFragmentException("Unknown literal type", odbc);
            }
        }

        private static Expression ToExpression(BooleanComparisonExpression cmp, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            // Special case for field = func() where func is defined in FetchXmlConditionMethods
            if (cmp.FirstExpression is ColumnReferenceExpression &&
                cmp.ComparisonType == BooleanComparisonType.Equals &&
                cmp.SecondExpression is FunctionCall func
                )
            {
                var parameters = func.Parameters.Select(p =>
                {
                    var paramExpr = p.ToExpression(context, contextParam, out var paramType);
                    return new KeyValuePair<Expression, DataTypeReference>(paramExpr, paramType);
                }).ToList();
                var colExpr = cmp.FirstExpression.ToExpression(context, contextParam, out var colType);
                parameters.Insert(0, new KeyValuePair<Expression, DataTypeReference>(colExpr, colType));
                var paramTypes = parameters.Select(p => p.Value).ToArray();
                var paramExpressions = parameters.Select(p => p.Key).ToArray();

                var fetchXmlComparison = GetMethod(context, typeof(FetchXmlConditionMethods), context.PrimaryDataSource, func, paramTypes, false, contextParam, ref paramExpressions, out sqlType);

                if (fetchXmlComparison != null)
                    return Expr.Call(fetchXmlComparison, paramExpressions);
            }

            sqlType = DataTypeHelpers.Bit;

            var lhs = cmp.FirstExpression.ToExpression(context, contextParam, out var lhsType);
            var rhs = cmp.SecondExpression.ToExpression(context, contextParam, out var rhsType);

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhsType, rhsType, context.PrimaryDataSource, out var type))
            {
                // Special case - we can filter on entity reference types by string
                if (lhs.Type == typeof(SqlEntityReference) && rhs.Type == typeof(SqlString) ||
                    lhs.Type == typeof(SqlString) && rhs.Type == typeof(SqlEntityReference))
                {
                    type = DataTypeHelpers.UniqueIdentifier;
                }
                else
                {
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {lhsType.ToSql()} and {rhsType.ToSql()}", cmp);
                }
            }

            if (!lhsType.IsSameAs(type))
                lhs = SqlTypeConverter.Convert(lhs, lhsType, type);

            if (!rhsType.IsSameAs(type))
            {
                // Special case to give more helpful & earlier error reporting for common problems
                if (cmp.FirstExpression is ColumnReferenceExpression col &&
                    cmp.SecondExpression is StringLiteral str &&
                    (
                        type.IsType(SqlDataTypeOption.Int) && !Int32.TryParse(str.Value, out _)
                        ||
                        type.IsType(SqlDataTypeOption.UniqueIdentifier) && !Guid.TryParse(str.Value, out _)
                    ) &&
                    context.Schema.ContainsColumn(col.GetColumnName() + "name", out var nameCol))
                {
                    throw new NotSupportedQueryFragmentException($"Cannot convert text value to {type.ToSql()}", str)
                    {
                        Suggestion = $"Did you mean to filter on the {nameCol} column instead?\r\n" + new string(' ', 26 + nameCol.Length) + "^^^^"
                    };
                }

                rhs = SqlTypeConverter.Convert(rhs, rhsType, type);
            }

            AssertCollationSensitive(type, cmp.ComparisonType.ToString().ToLowerInvariant() + " operation", cmp);

            switch (cmp.ComparisonType)
            {
                case BooleanComparisonType.Equals:
                    return Expression.Equal(lhs, rhs);

                case BooleanComparisonType.GreaterThan:
                    return Expression.GreaterThan(lhs, rhs);

                case BooleanComparisonType.GreaterThanOrEqualTo:
                case BooleanComparisonType.NotLessThan:
                    return Expression.GreaterThanOrEqual(lhs, rhs);

                case BooleanComparisonType.LessThan:
                    return Expression.LessThan(lhs, rhs);

                case BooleanComparisonType.LessThanOrEqualTo:
                case BooleanComparisonType.NotGreaterThan:
                    return Expression.LessThanOrEqual(lhs, rhs);

                case BooleanComparisonType.NotEqualToBrackets:
                case BooleanComparisonType.NotEqualToExclamation:
                    return Expression.NotEqual(lhs, rhs);

                default:
                    throw new NotSupportedQueryFragmentException("Unknown comparison type", cmp);
            }
        }

        private static Expression ToExpression(DistinctPredicate distinct, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = DataTypeHelpers.Bit;

            var lhs = distinct.FirstExpression.ToExpression(context, contextParam, out var lhsType);
            var rhs = distinct.SecondExpression.ToExpression(context, contextParam, out var rhsType);

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhsType, rhsType, context.PrimaryDataSource, out var type))
            {
                // Special case - we can filter on entity reference types by string
                if (lhs.Type == typeof(SqlEntityReference) && rhs.Type == typeof(SqlString) ||
                    lhs.Type == typeof(SqlString) && rhs.Type == typeof(SqlEntityReference))
                {
                    type = DataTypeHelpers.UniqueIdentifier;
                }
                else
                {
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {lhsType.ToSql()} and {rhsType.ToSql()}", distinct);
                }
            }

            if (!lhsType.IsSameAs(type))
                lhs = SqlTypeConverter.Convert(lhs, lhsType, type);

            if (!rhsType.IsSameAs(type))
            {
                // Special case to give more helpful & earlier error reporting for common problems
                if (distinct.FirstExpression is ColumnReferenceExpression col &&
                    distinct.SecondExpression is StringLiteral str &&
                    (
                        type.IsType(SqlDataTypeOption.Int) && !Int32.TryParse(str.Value, out _)
                        ||
                        type.IsType(SqlDataTypeOption.UniqueIdentifier) && !Guid.TryParse(str.Value, out _)
                    ) &&
                    context.Schema.ContainsColumn(col.GetColumnName() + "name", out var nameCol))
                {
                    throw new NotSupportedQueryFragmentException($"Cannot convert text value to {type.ToSql()}", str)
                    {
                        Suggestion = $"Did you mean to filter on the {nameCol} column instead?\r\n" + new string(' ', 26 + nameCol.Length) + "^^^^"
                    };
                }

                rhs = SqlTypeConverter.Convert(rhs, rhsType, type);
            }

            AssertCollationSensitive(type, "IS DISTINCT FROM operation", distinct);

            // Using linked server decoding pseudocode from https://learn.microsoft.com/en-us/sql/t-sql/queries/is-distinct-from-transact-sql?view=sql-server-ver16#remarks
            var expr = (Expression) Expression.AndAlso(
                Expression.OrElse(
                    Expression.OrElse(
                        SqlTypeConverter.NullCheck(rhs),
                        SqlTypeConverter.NullCheck(lhs)
                        ),
                    Expression.IsTrue(Expression.NotEqual(lhs, rhs))
                    ),
                Expression.Not(
                    Expression.AndAlso(
                        SqlTypeConverter.NullCheck(lhs),
                        SqlTypeConverter.NullCheck(rhs)
                        )
                    )
                );

            if (distinct.IsNot)
                expr = Expression.Not(expr);

            return expr;
        }

        private static Expression ToExpression(BooleanBinaryExpression bin, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            sqlType = DataTypeHelpers.Bit;

            var lhs = bin.FirstExpression.ToExpression(context, contextParam, out _);
            var rhs = bin.SecondExpression.ToExpression(context, contextParam, out _);

            if (bin.BinaryExpressionType == BooleanBinaryExpressionType.And)
                return Expression.AndAlso(lhs, rhs);

            return Expression.OrElse(lhs, rhs);
        }

        private static Expression ToExpression(BooleanParenthesisExpression paren, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            return paren.Expression.ToExpression(context, contextParam, out sqlType);
        }

        private static Expression ToExpression(Microsoft.SqlServer.TransactSql.ScriptDom.BinaryExpression bin, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            var lhs = bin.FirstExpression.ToExpression(context, contextParam, out var lhsSqlType);
            var rhs = bin.SecondExpression.ToExpression(context, contextParam, out var rhsSqlType);

            if (!SqlTypeConverter.CanMakeConsistentTypes(lhsSqlType, rhsSqlType, context.PrimaryDataSource, out var type))
                throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {lhsSqlType.ToSql()} and {rhsSqlType.ToSql()}", bin);

            // For decimal types, need to work out the precision and scale of the result depending on the type of operation
            if (type is SqlDataTypeReference sqlTargetType && (sqlTargetType.SqlDataTypeOption == SqlDataTypeOption.Numeric || sqlTargetType.SqlDataTypeOption == SqlDataTypeOption.Decimal))
            {
                var p1 = lhsSqlType.GetPrecision();
                var s1 = lhsSqlType.GetScale();
                var p2 = rhsSqlType.GetPrecision();
                var s2 = rhsSqlType.GetScale();

                var p = type.GetPrecision();
                var s = type.GetScale();

                switch (bin.BinaryExpressionType)
                {
                    case BinaryExpressionType.Add:
                    case BinaryExpressionType.Subtract:
                        p = (short)(Math.Max(s1, s2) + Math.Max(p1 - s1, p2 - s2) + 1);
                        s = Math.Max(s1, s2);
                        break;

                    case BinaryExpressionType.Multiply:
                        p = (short)(p1 + p2 + 1);
                        s = (short)(s1 + s2);
                        break;

                    case BinaryExpressionType.Divide:
                        p = (short)(p1 - s1 + s2 + Math.Max(6, s1 + p2 + 1));
                        s = (short)(Math.Max(6, s1 + p2 + 1));
                        break;
                }

                if (p > 38)
                {
                    switch (bin.BinaryExpressionType)
                    {
                        case BinaryExpressionType.Add:
                        case BinaryExpressionType.Subtract:
                            p = 38;
                            s = (short)(p - Math.Max(p1 - s1, p2 - s2));
                            break;

                        case BinaryExpressionType.Multiply:
                        case BinaryExpressionType.Divide:
                            if ((p - s) < 32)
                                s = (short)(Math.Min(s, 38 - (p - s)));
                            else if (s > 6 && (p - s) > 32)
                                s = 6;

                            if (p > 38)
                                p = 38;
                            break;
                    }
                }

                type = DataTypeHelpers.Decimal(p, s);

                if (lhs.Type != typeof(SqlDecimal))
                    lhs = SqlTypeConverter.Convert(lhs, lhsSqlType, DataTypeHelpers.Decimal(lhsSqlType.GetPrecision(), lhsSqlType.GetScale()));
                if (rhs.Type != typeof(SqlDecimal))
                    rhs = SqlTypeConverter.Convert(rhs, rhsSqlType, DataTypeHelpers.Decimal(rhsSqlType.GetPrecision(), rhsSqlType.GetScale()));
            }
            else
            {
                if (!lhsSqlType.IsSameAs(type))
                    lhs = SqlTypeConverter.Convert(lhs, lhsSqlType, type);

                if (!rhsSqlType.IsSameAs(type))
                    rhs = SqlTypeConverter.Convert(rhs, rhsSqlType, type);
            }

            sqlType = null;
            Expression expr;

            switch (bin.BinaryExpressionType)
            {
                case BinaryExpressionType.Add:
                    // Special case for SqlDateTime
                    if (lhs.Type == typeof(SqlDateTime) && rhs.Type == typeof(SqlDateTime))
                        expr = Expr.Call(() => AddSqlDateTime(Expr.Arg<SqlDateTime>(), Expr.Arg<SqlDateTime>()), lhs, rhs);
                    else
                        expr = Expression.Add(lhs, rhs);

                    // Special case for SqlString length & collation calculation
                    if (lhsSqlType is SqlDataTypeReferenceWithCollation lhsSql &&
                        rhsSqlType is SqlDataTypeReferenceWithCollation rhsSql &&
                        lhs.Type == typeof(SqlString) &&
                        rhs.Type == typeof(SqlString) &&
                        lhsSql.Parameters.Count == 1 &&
                        rhsSql.Parameters.Count == 1)
                    {
                        int lhsLength;
                        int rhsLength;

                        if (lhsSql.Parameters[0].LiteralType != LiteralType.Integer ||
                            !Int32.TryParse(lhsSql.Parameters[0].Value, out lhsLength))
                            lhsLength = 8000;

                        if (rhsSql.Parameters[0].LiteralType != LiteralType.Integer ||
                            !Int32.TryParse(rhsSql.Parameters[0].Value, out rhsLength))
                            rhsLength = 8000;

                        var length = lhsLength + rhsLength;

                        if (!SqlDataTypeReferenceWithCollation.TryConvertCollation(lhsSql, rhsSql, out var collation, out var collationLabel))
                            throw new NotSupportedQueryFragmentException($"Cannot resolve collation conflict between '{lhsSql.Collation.Name}' and {rhsSql.Collation.Name}' in add operation", bin);

                        sqlType = new SqlDataTypeReferenceWithCollation
                        {
                            SqlDataTypeOption = ((SqlDataTypeReference)type).SqlDataTypeOption,
                            Parameters = { length <= 8000 ? (Literal)new IntegerLiteral { Value = length.ToString(CultureInfo.InvariantCulture) } : new MaxLiteral() },
                            Collation = collation,
                            CollationLabel = collationLabel
                        };
                    }
                    break;

                case BinaryExpressionType.Subtract:
                    // Special case for SqlDateTime
                    if (lhs.Type == typeof(SqlDateTime) && rhs.Type == typeof(SqlDateTime))
                        expr = Expr.Call(() => SubtractSqlDateTime(Expr.Arg<SqlDateTime>(), Expr.Arg<SqlDateTime>()), lhs, rhs);
                    else
                        expr = Expression.Subtract(lhs, rhs);
                    break;

                case BinaryExpressionType.Multiply:
                    expr = Expression.Multiply(lhs, rhs);
                    break;

                case BinaryExpressionType.Divide:
                    expr = Expression.Divide(lhs, rhs);
                    break;

                case BinaryExpressionType.Modulo:
                    expr = Expression.Modulo(lhs, rhs);
                    break;

                case BinaryExpressionType.BitwiseAnd:
                    expr = Expression.And(lhs, rhs);
                    break;

                case BinaryExpressionType.BitwiseOr:
                    expr = Expression.Or(lhs, rhs);
                    break;

                case BinaryExpressionType.BitwiseXor:
                    expr = Expression.ExclusiveOr(lhs, rhs);
                    break;

                default:
                    throw new NotSupportedQueryFragmentException("Unknown operator", bin);
            }

            if (sqlType == null && expr.Type == typeof(SqlDecimal))
                sqlType = type;

            if (sqlType == null)
                sqlType = expr.Type.ToSqlType(context.PrimaryDataSource);

            return expr;
        }

        private static SqlDateTime AddSqlDateTime(SqlDateTime lhs, SqlDateTime rhs)
        {
            if (lhs.IsNull || rhs.IsNull)
                return SqlDateTime.Null;

            // Convert the second value to the TimeSpan difference between 1900-01-01 and the given value first
            var ts = rhs.Value - new DateTime(1900, 1, 1);
            return lhs + ts;
        }

        private static SqlDateTime SubtractSqlDateTime(SqlDateTime lhs, SqlDateTime rhs)
        {
            if (lhs.IsNull || rhs.IsNull)
                return SqlDateTime.Null;

            // Convert the second value to the TimeSpan difference between 1900-01-01 and the given value first
            var ts = rhs.Value - new DateTime(1900, 1, 1);
            return lhs - ts;
        }

        private static MethodInfo GetMethod(FunctionCall func, ExpressionCompilationContext context, ParameterExpression contextParam, out Expression[] paramExpressions, out DataTypeReference sqlType)
        {
            KeyValuePair<Expression, DataTypeReference>[] paramExpressionsWithType;

            // Special case for DATEPART / DATEDIFF / DATEADD - first parameter looks like a field but is actually an identifier
            if (func.FunctionName.Value.Equals("DATEPART", StringComparison.OrdinalIgnoreCase) ||
                func.FunctionName.Value.Equals("DATEDIFF", StringComparison.OrdinalIgnoreCase) ||
                func.FunctionName.Value.Equals("DATEADD", StringComparison.OrdinalIgnoreCase))
            {
                paramExpressionsWithType = func.Parameters
                    .Select((param, index) =>
                    {
                        if (index == 0)
                        {
                            // Check parameter is an expected datepart value
                            if (!(param is ColumnReferenceExpression col))
                                throw new NotSupportedQueryFragmentException("Expected a datepart name", param);

                            try
                            {
                                ExpressionFunctions.DatePartToInterval(col.MultiPartIdentifier.Identifiers.Single().Value);
                            }
                            catch
                            {
                                throw new NotSupportedQueryFragmentException("Expected a datepart name", param);
                            }

                            return new KeyValuePair<Expression, DataTypeReference>(Expression.Constant(col.MultiPartIdentifier.Identifiers.Single().Value), DataTypeHelpers.NVarChar(col.MultiPartIdentifier.Identifiers.Single().Value.Length, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault));
                        }

                        var paramExpr = param.ToExpression(context, contextParam, out var paramType);
                        return new KeyValuePair<Expression, DataTypeReference>(paramExpr, paramType);
                    })
                    .ToArray();
            }
            else
            {
                paramExpressionsWithType = func.Parameters
                    .Select(param =>
                    {
                        var paramExpr = param.ToExpression(context, contextParam, out var paramType);
                        return new KeyValuePair<Expression, DataTypeReference>(paramExpr, paramType);
                    })
                    .ToArray();
            }

            if (func.CallTarget != null)
            {
                // If this function has a target (e.g. xml functions), add the target as the first parameter
                var targetParam = func.CallTarget.ToExpression(context, contextParam, out var targetType);
                paramExpressionsWithType = new[] { new KeyValuePair<Expression, DataTypeReference>(targetParam, targetType) }.Concat(paramExpressionsWithType).ToArray();
            }

            paramExpressions = paramExpressionsWithType
                .Select(kvp => kvp.Key)
                .ToArray();

            return GetMethod(context, typeof(ExpressionFunctions), context.PrimaryDataSource, func, paramExpressionsWithType.Select(kvp => kvp.Value).ToArray(), true, contextParam, ref paramExpressions, out sqlType);
        }

        private static MethodInfo GetMethod(ExpressionCompilationContext context, Type targetType, DataSource primaryDataSource, FunctionCall func, DataTypeReference[] paramTypes, bool throwOnMissing, ParameterExpression contextParam, ref Expression[] paramExpressions, out DataTypeReference sqlType)
        {
            // Find a method that implements this function
            var methods = targetType
                .GetMethods(BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.Static)
                .Where(m => m.Name.Equals(func.FunctionName.Value, StringComparison.OrdinalIgnoreCase))
                .ToList();

            if (methods.Count == 0)
            {
                if (throwOnMissing)
                    throw new NotSupportedQueryFragmentException("Unknown function", func);

                sqlType = DataTypeHelpers.Int;
                return null;
            }

            // Check parameter count is correct
            var correctParameterCount = methods
                .Select(m => new { Method = m, Parameters = m.GetParameters() })
                .Where(m =>
                {
                    var allowedParameters = m.Parameters.Where(p => p.GetCustomAttribute<SourceTypeAttribute>() == null && p.ParameterType != typeof(ExpressionExecutionContext) && p.ParameterType != typeof(INodeSchema));
                    var requiredParameters = allowedParameters.Where(p => p.GetCustomAttribute<OptionalAttribute>() == null);
                    var isArrayParameter = requiredParameters.Any() && requiredParameters.Last().ParameterType.IsArray;

                    if (paramTypes.Length < requiredParameters.Count())
                        return false;

                    if (paramTypes.Length > allowedParameters.Count() && !isArrayParameter)
                        return false;

                    return true;
                })
                .ToList();

            if (correctParameterCount.Count == 0)
                throw new NotSupportedQueryFragmentException($"Method expects {methods[0].GetParameters().Length} parameters", func);

            if (correctParameterCount.Count > 1)
                throw new NotSupportedQueryFragmentException("Ambiguous method", func);

            var method = correctParameterCount[0].Method;
            var parameters = correctParameterCount[0].Parameters;

            if (correctParameterCount[0].Method.IsGenericMethodDefinition)
            {
                // Create the generic method based on the type of the generic arguments
                var genericArguments = correctParameterCount[0].Method.GetGenericArguments();
                var genericArgumentValues = new Type[genericArguments.Length];

                foreach (var param in correctParameterCount[0].Parameters)
                {
                    for (var i = 0; i < genericArguments.Length; i++)
                    {
                        if (param.ParameterType == genericArguments[i] && genericArgumentValues[i] == null)
                            genericArgumentValues[i] = paramTypes[i].ToNetType(out _);
                    }
                }

                method = method.MakeGenericMethod(genericArgumentValues);
                parameters = method.GetParameters();
            }

            sqlType = null;

            if (method.ReturnType == typeof(SqlString))
            {
                // Use the [MaxLength(value)] attribute from the method where available
                var methodMaxLength = method.GetCustomAttribute<MaxLengthAttribute>();

                if (methodMaxLength?.MaxLength != null)
                    sqlType = DataTypeHelpers.NVarChar(methodMaxLength.MaxLength.Value, primaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

                // Work out precise type from parameter with [MaxLength] attribute where available
                for (var i = 0; i < parameters.Length; i++)
                {
                    if (parameters[i].GetCustomAttribute<MaxLengthAttribute>() != null)
                    {
                        if (parameters[i].ParameterType == typeof(SqlInt32) && paramExpressions[i] is ConstantExpression lengthConst && lengthConst.Value is SqlInt32 length && !length.IsNull)
                            sqlType = DataTypeHelpers.NVarChar(length.Value, primaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);
                        else if (parameters[i].ParameterType == typeof(SqlString) && paramTypes[i].ToNetType(out var sqlStringType) == typeof(SqlString))
                            sqlType = paramTypes[i];

                        break;
                    }
                }
            }

            // Check parameter types can be converted
            var paramOffset = targetType == typeof(FetchXmlConditionMethods) ? 1 : 0;

            for (var i = 0; i < parameters.Length; i++)
            {
                var paramType = parameters[i].ParameterType;

                if (i == parameters.Length - 1 && paramTypes.Length >= parameters.Length && paramType.IsArray)
                    paramType = paramType.GetElementType();

                var paramIndex = i;

                if (func.CallTarget != null)
                    paramIndex--;

                if (paramTypes.Length < parameters.Length && paramType == typeof(ExpressionExecutionContext))
                {
                    var paramsWithOptions = new Expression[paramExpressions.Length + 1];
                    paramExpressions.CopyTo(paramsWithOptions, 0);
                    paramsWithOptions[paramExpressions.Length] = contextParam;
                    paramExpressions = paramsWithOptions;
                    continue;
                }

                if (paramTypes.Length < parameters.Length && paramType == typeof(INodeSchema))
                {
                    var paramsWithOptions = new Expression[paramExpressions.Length + 1];
                    paramExpressions.CopyTo(paramsWithOptions, 0);
                    paramsWithOptions[paramExpressions.Length] = Expression.Constant(context.Schema);
                    paramExpressions = paramsWithOptions;
                    continue;
                }

                if (i >= paramTypes.Length && parameters[i].GetCustomAttribute<OptionalAttribute>() != null)
                {
                    var paramsWithDefaultValue = new Expression[paramExpressions.Length + 1];
                    paramExpressions.CopyTo(paramsWithDefaultValue, 0);
                    paramsWithDefaultValue[i] = Expression.Constant(SqlTypeConverter.GetNullValue(paramType));
                    paramExpressions = paramsWithDefaultValue;
                    continue;
                }

                if (paramType == typeof(DataTypeReference))
                {
                    if (parameters[i].GetCustomAttribute<SourceTypeAttribute>() != null)
                    {
                        var paramsWithType = new Expression[paramExpressions.Length + 1];
                        paramExpressions.CopyTo(paramsWithType, 0);
                        paramsWithType[i] = Expression.Constant(paramTypes[i - 1]);
                        paramExpressions = paramsWithType;
                    }
                    else
                    {
                        // Expect only a literal string
                        if (!(func.Parameters[paramIndex] is StringLiteral typeLiteral))
                            throw new NotSupportedQueryFragmentException($"Only string literals are supported for type parameters", func.Parameters[i]);

                        if (!DataTypeHelpers.TryParse(context, typeLiteral.Value, out var parsedType))
                            throw new NotSupportedQueryFragmentException("Unknown type name", typeLiteral);

                        paramExpressions[i] = Expression.Constant(parsedType);

                        if (parameters[i].GetCustomAttribute<TargetTypeAttribute>() != null)
                            sqlType = parsedType;
                    }

                    continue;
                }

                if (paramType == typeof(XPath2Expression))
                {
                    // Expect only a literal string
                    if (!(func.Parameters[paramIndex] is StringLiteral xpathLiteral))
                        throw new NotSupportedQueryFragmentException($"The argument {i} of the XML data type method \"{func.FunctionName.Value}\" must be a string literal");

                    paramExpressions[i] = Expression.Constant(XPath2Expression.Compile(xpathLiteral.Value, XPath2ExpressionContext.XmlNamespaceManager));
                    continue;
                }

                if (!SqlTypeConverter.CanChangeTypeImplicit(paramTypes[i], paramType.ToSqlType(primaryDataSource)))
                    throw new NotSupportedQueryFragmentException($"Cannot convert {paramTypes[i].ToSql()} to {paramType.ToSqlType(primaryDataSource).ToSql()}", i < paramOffset ? func : func.Parameters[i - paramOffset]);
            }

            for (var i = parameters.Length; i < paramTypes.Length; i++)
            {
                var paramType = parameters.Last().ParameterType.GetElementType();

                if (!SqlTypeConverter.CanChangeTypeImplicit(paramTypes[i], paramType.ToSqlType(primaryDataSource)))
                    throw new NotSupportedQueryFragmentException($"Cannot convert {paramTypes[i].ToSql()} to {paramType.ToSqlType(primaryDataSource).ToSql()}", i < paramOffset ? func : func.Parameters[i - paramOffset]);
            }

            if (sqlType == null)
                sqlType = method.ReturnType.ToSqlType(primaryDataSource);

            if (method.GetCustomAttribute(typeof(CollationSensitiveAttribute)) != null)
            {
                // If method is collation sensitive:
                // 1. check all string parameters can be converted to a consistent collation
                // 2. check the consistent collation label is not no-collation
                // 3. use the same collation for the return type
                SqlDataTypeReferenceWithCollation collation = null;

                foreach (var paramType in paramTypes)
                {
                    if (!(paramType is SqlDataTypeReferenceWithCollation collationParam))
                        continue;

                    if (collation == null)
                    {
                        collation = collationParam;
                        continue;
                    }

                    if (!SqlDataTypeReferenceWithCollation.TryConvertCollation(collation, collationParam, out var consistentCollation, out var collationLabel))
                        throw new NotSupportedQueryFragmentException($"Cannot resolve collation conflict between '{collation.Collation.Name}' and {collationParam.Collation.Name}' in {func.FunctionName.Value.ToLowerInvariant()} operation", func);

                    collation = new SqlDataTypeReferenceWithCollation
                    {
                        Collation = consistentCollation,
                        CollationLabel = collationLabel
                    };
                }

                AssertCollationSensitive(collation, func.FunctionName.Value.ToLowerInvariant() + " operation", func);

                for (var i = 0; i < paramTypes.Length; i++)
                {
                    if (!(paramTypes[i] is SqlDataTypeReferenceWithCollation collationParam))
                        continue;

                    if (!collationParam.Collation.Equals(collation.Collation))
                    {
                        paramExpressions[i] = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), paramExpressions[i], Expression.Constant(collation.Collation));
                        paramTypes[i] = new SqlDataTypeReferenceWithCollation
                        {
                            SqlDataTypeOption = collationParam.SqlDataTypeOption,
                            Collation = collation.Collation,
                            CollationLabel = CollationLabel.Explicit
                        };

                        foreach (var param in collationParam.Parameters)
                            ((SqlDataTypeReferenceWithCollation)paramTypes[i]).Parameters.Add(param);
                    }
                }

                if (sqlType is SqlDataTypeReferenceWithCollation outputCollation)
                {
                    outputCollation.Collation = collation.Collation;
                    outputCollation.CollationLabel = collation.CollationLabel;
                }
            }

            return method;
        }

        private static Expression ToExpression(this FunctionCall func, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            if (func.OverClause != null)
                throw new NotSupportedQueryFragmentException("Window functions are not supported", func);

            if (func.WithinGroupClause != null)
                throw new NotSupportedQueryFragmentException($"The function '{func.FunctionName.Value}' may not have a WITHIN GROUP clause", func);

            // Special case: ExplicitCollation is a pseudo-function that's introduced by the ExplicitCollationVisitor to wrap
            // primary expressions with a collation definition. The inner expression will already have applied the collation
            // change so we can return it without any further processing
            if (func.FunctionName.Value == "ExplicitCollation" && func.Parameters.Count == 1)
            {
                var converted = func.Parameters[0].ToExpression(context, contextParam, out sqlType);

                if (!(sqlType is SqlDataTypeReferenceWithCollation coll) ||
                    !coll.SqlDataTypeOption.IsStringType() ||
                    coll.Collation == null ||
                    coll.CollationLabel != CollationLabel.Explicit)
                {
                    throw new NotSupportedQueryFragmentException("Unknown function", func);
                }

                return converted;
            }

            // Find the method to call and get the expressions for the parameter values
            var method = GetMethod(func, context, contextParam, out var paramValues, out sqlType);

            // Convert the parameters to the expected types
            var parameters = method.GetParameters();

            for (var i = 0; i < parameters.Length; i++)
            {
                if (paramValues[i].Type != parameters[i].ParameterType)
                    paramValues[i] = SqlTypeConverter.Convert(paramValues[i], parameters[i].ParameterType);
            }

            var expr = (Expression) Expression.Call(method, paramValues);

            if (expr.Type == typeof(object) && parameters.Any(p => p.GetCustomAttribute<TargetTypeAttribute>() != null))
                expr = Expression.Convert(expr, sqlType.ToNetType(out _));

            return expr;
        }

        private static Expression ToExpression(this ParenthesisExpression paren, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            return paren.Expression.ToExpression(context, contextParam, out sqlType);
        }

        private static Expression ToExpression(this ExpressionCallTarget callTarget, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            return callTarget.Expression.ToExpression(context, contextParam, out sqlType);
        }

        private static Expression ToExpression(this Microsoft.SqlServer.TransactSql.ScriptDom.UnaryExpression unary, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            var value = unary.Expression.ToExpression(context, contextParam, out sqlType);
            
            switch (unary.UnaryExpressionType)
            {
                case UnaryExpressionType.Positive:
                    return Expression.UnaryPlus(value);

                case UnaryExpressionType.Negative:
                    return Expression.Negate(value);

                case UnaryExpressionType.BitwiseNot:
                    return Expression.Not(value);

                default:
                    throw new NotSupportedQueryFragmentException("Unknown unary operator", unary);
            }
        }

        private static Expression ToExpression(this InPredicate inPred, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            if (inPred.Subquery != null)
                throw new NotSupportedQueryFragmentException("Subquery should have been eliminated by query plan", inPred);

            var exprValue = inPred.Expression.ToExpression(context, contextParam, out var exprType);

            Expression result = null;

            foreach (var value in inPred.Values)
            {
                var comparisonValue = value.ToExpression(context, contextParam, out var comparisonType);

                if (!SqlTypeConverter.CanMakeConsistentTypes(exprType, comparisonType, context.PrimaryDataSource, out var type))
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {exprType.ToSql()} and {comparisonType.ToSql()}", inPred);

                var convertedExprValue = exprValue;

                if (!exprType.IsSameAs(type))
                    convertedExprValue = SqlTypeConverter.Convert(convertedExprValue, exprType, type);

                if (!comparisonType.IsSameAs(type))
                    comparisonValue = SqlTypeConverter.Convert(comparisonValue, comparisonType, type);

                var comparison = inPred.NotDefined ? Expression.NotEqual(convertedExprValue, comparisonValue) : Expression.Equal(convertedExprValue, comparisonValue);

                if (result == null)
                    result = comparison;
                else
                    result = inPred.NotDefined ? Expression.AndAlso(result, comparison) : Expression.OrElse(result, comparison);
            }

            sqlType = DataTypeHelpers.Bit;
            return result;
        }

        private static Expression ToExpression(this VariableReference var, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            if (context.ParameterTypes == null || !context.ParameterTypes.TryGetValue(var.Name, out sqlType))
                throw new NotSupportedQueryFragmentException("Undefined variable", var);

            var parameters = Expression.Property(contextParam, nameof(ExpressionExecutionContext.ParameterValues));
            var expr = Expression.Property(parameters, typeof(IDictionary<string, object>).GetCustomAttribute<DefaultMemberAttribute>().MemberName, Expression.Constant(var.Name));
            return Expression.Convert(expr, sqlType.ToNetType(out _));
        }

        private static Expression ToExpression(this GlobalVariableExpression var, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            if (context.ParameterTypes == null || !context.ParameterTypes.TryGetValue(var.Name, out sqlType))
                throw new NotSupportedQueryFragmentException("Undefined variable", var);

            var parameters = Expression.Property(contextParam, nameof(ExpressionExecutionContext.ParameterValues));
            var expr = Expression.Property(parameters, typeof(IDictionary<string, object>).GetCustomAttribute<DefaultMemberAttribute>().MemberName, Expression.Constant(var.Name));
            return Expression.Convert(expr, sqlType.ToNetType(out _));
        }

        private static Expression ToExpression(this BooleanIsNullExpression isNull, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            var value = isNull.Expression.ToExpression(context, contextParam, out _);
            value = SqlTypeConverter.NullCheck(value);

            if (isNull.IsNot)
                value = Expression.Not(value);

            value = SqlTypeConverter.Convert(value, typeof(SqlBoolean));
            sqlType = DataTypeHelpers.Bit;
            return value;
        }

        private static Expression ToExpression(this LikePredicate like, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            DataTypeReference escapeType = null;

            var value = like.FirstExpression.ToExpression(context, contextParam, out var valueType);
            var pattern = like.SecondExpression.ToExpression(context, contextParam, out var patternType);
            var escape = like.EscapeExpression?.ToExpression(context, contextParam, out escapeType);

            sqlType = DataTypeHelpers.Bit;
            var stringType = DataTypeHelpers.NVarChar(Int32.MaxValue, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

            if (value.Type != typeof(SqlString))
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(valueType, stringType))
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {valueType.ToSql()} and {stringType.ToSql()}", like.FirstExpression);

                value = SqlTypeConverter.Convert(value, valueType, stringType);
                valueType = stringType;
            }

            if (pattern.Type != typeof(SqlString))
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(patternType, stringType))
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {patternType.ToSql()} and {stringType.ToSql()}", like.SecondExpression);

                pattern = SqlTypeConverter.Convert(pattern, patternType, stringType);
                patternType = stringType;
            }

            if (escape != null && escape.Type != typeof(SqlString))
            {
                if (!SqlTypeConverter.CanChangeTypeImplicit(escapeType, stringType))
                    throw new NotSupportedQueryFragmentException($"No implicit conversion exists for types {escapeType.ToSql()} and {stringType.ToSql()}", like.EscapeExpression);

                escape = SqlTypeConverter.Convert(escape, escapeType, stringType);
                escapeType = stringType;
            }

            if (!SqlDataTypeReferenceWithCollation.TryConvertCollation((SqlDataTypeReference)valueType, (SqlDataTypeReference)patternType, out var collation, out var collationLabel))
                throw new NotSupportedQueryFragmentException($"Cannot resolve collation conflict between '{((SqlDataTypeReferenceWithCollation)valueType).Collation.Name}' and {((SqlDataTypeReferenceWithCollation)patternType).Collation.Name}' in like operation", like);

            ((SqlDataTypeReferenceWithCollation)stringType).Collation = collation;
            ((SqlDataTypeReferenceWithCollation)stringType).CollationLabel = collationLabel;

            if (escapeType != null && !SqlDataTypeReferenceWithCollation.TryConvertCollation(stringType, (SqlDataTypeReference)escapeType, out collation, out collationLabel))
            {
                throw new NotSupportedQueryFragmentException($"Cannot resolve collation conflict between '{((SqlDataTypeReferenceWithCollation)stringType).Collation.Name}' and {((SqlDataTypeReferenceWithCollation)escapeType).Collation.Name}' in like operation", like);
            }
            else
            {
                ((SqlDataTypeReferenceWithCollation)stringType).Collation = collation;
                ((SqlDataTypeReferenceWithCollation)stringType).CollationLabel = collationLabel;
            }

            AssertCollationSensitive(stringType, "like operation", like);

            if (escape == null)
                escape = Expression.Constant(SqlString.Null);

            if (pattern.NodeType == ExpressionType.Constant && (escape == null || escape.NodeType == ExpressionType.Constant))
            {
                // Do a one-off conversion to regex
                try
                {
                    var regex = LikeToRegex(SqlTypeConverter.ConvertCollation((SqlString)((ConstantExpression)pattern).Value, collation), (SqlString)(((ConstantExpression)escape)?.Value ?? SqlString.Null), false);
                    return Expr.Call(() => Like(Expr.Arg<SqlString>(), Expr.Arg<Regex>(), Expr.Arg<bool>()), value, Expression.Constant(regex), Expression.Constant(like.NotDefined));
                }
                catch (ArgumentException ex)
                {
                    throw new NotSupportedQueryFragmentException(ex.Message, like.SecondExpression);
                }
            }

            value = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), value, Expression.Constant(collation));
            pattern = Expr.Call(() => SqlTypeConverter.ConvertCollation(Expr.Arg<SqlString>(), Expr.Arg<Collation>()), pattern, Expression.Constant(collation));

            return Expr.Call(() => Like(Expr.Arg<SqlString>(), Expr.Arg<SqlString>(), Expr.Arg<SqlString>(), Expr.Arg<bool>()), value, pattern, escape, Expression.Constant(like.NotDefined));
        }

        internal static Regex LikeToRegex(SqlString pattern, SqlString escape, bool patIndex)
        {
            var regexBuilder = new StringBuilder();
            var pat = pattern.Value;

            if (pattern.SqlCompareOptions.HasFlag(SqlCompareOptions.IgnoreNonSpace))
                pat = RemoveDiacritics(pat);

            var endWildcard = false;

            if (!patIndex)
            {
                regexBuilder.Append("^");
            }
            else
            {
                if (!pattern.Value.StartsWith("%"))
                    regexBuilder.Append("^");
                else
                    pat = pat.TrimStart('%');

                endWildcard = pat.EndsWith("%");

                if (endWildcard)
                    pat = pat.TrimEnd('%');
            }

            var escaped = false;
            var inRange = false;
            var escapeChar = escape.IsNull ? '\0' : escape.Value[0];

            foreach (var ch in pat)
            {
                if (escapeChar != '\0' && ch == escapeChar)
                {
                    escaped = true;
                    continue;
                }

                if (escaped)
                {
                    regexBuilder.Append(Regex.Escape(ch.ToString()));
                    escaped = false;
                    continue;
                }

                if (ch == '[' && !inRange)
                {
                    regexBuilder.Append("[");
                    inRange = true;
                    continue;
                }

                if (ch == ']' && inRange)
                {
                    regexBuilder.Append("]");
                    inRange = false;
                    continue;
                }

                if ((ch == '^' || ch == '-') && inRange)
                {
                    regexBuilder.Append(ch);
                    continue;
                }

                if (inRange)
                {
                    regexBuilder.Append(Regex.Escape(ch.ToString()));
                    continue;
                }

                if (ch == '%')
                {
                    regexBuilder.Append(".*");
                    continue;
                }

                if (ch == '_')
                {
                    regexBuilder.Append('.');
                    continue;
                }

                regexBuilder.Append(Regex.Escape(ch.ToString()));
            }

            if (escaped || inRange)
                throw new ArgumentException("Invalid LIKE pattern");

            if (!patIndex || !endWildcard)
                regexBuilder.Append("$");

            return new Regex(regexBuilder.ToString(), pattern.SqlCompareOptions.HasFlag(SqlCompareOptions.IgnoreCase) ? RegexOptions.IgnoreCase : RegexOptions.None);
        }

        private static SqlBoolean Like(SqlString value, SqlString pattern, SqlString escape, bool not)
        {
            if (value.IsNull || pattern.IsNull)
                return false;

            // Convert the LIKE pattern to a regex
            var regex = LikeToRegex(pattern, escape, false);

            return Like(value, regex, not);
        }

        private static SqlBoolean Like(SqlString value, Regex pattern, bool not)
        {
            if (value.IsNull)
                return false;

            var text = value.Value;

            if (value.SqlCompareOptions.HasFlag(SqlCompareOptions.IgnoreNonSpace))
                text = RemoveDiacritics(text);

            var result = pattern.IsMatch(text);

            if (not)
                result = !result;

            return result;
        }

        /// <summary>
        /// Removes accents from a string, used for accent-insensitive collations
        /// </summary>
        /// <ref>https://stackoverflow.com/a/249126/269629</ref>
        /// <param name="text">The text to remove the accents from</param>
        /// <returns>A version of the <paramref name="text"/> with accents removed</returns>
        internal static string RemoveDiacritics(string text)
        {
            var normalizedString = text.Normalize(NormalizationForm.FormD);
            var stringBuilder = new StringBuilder(capacity: normalizedString.Length);

            for (int i = 0; i < normalizedString.Length; i++)
            {
                char c = normalizedString[i];
                var unicodeCategory = CharUnicodeInfo.GetUnicodeCategory(c);
                if (unicodeCategory != UnicodeCategory.NonSpacingMark)
                {
                    stringBuilder.Append(c);
                }
            }

            return stringBuilder
                .ToString()
                .Normalize(NormalizationForm.FormC);
        }

        private static Expression ToExpression(this SimpleCaseExpression simpleCase, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            // Convert all the different elements to expressions
            var value = simpleCase.InputExpression.ToExpression(context, contextParam, out var valueType);
            var whenClauses = simpleCase.WhenClauses.Select(when =>
            {
                var whenExpr = when.WhenExpression.ToExpression(context, contextParam, out var whenType);
                return new { Expression = whenExpr, Type = whenType };
            }).ToList();
            var caseTypes = new DataTypeReference[whenClauses.Count];
            var thenClauses = simpleCase.WhenClauses.Select(when =>
            {
                var thenExpr = when.ThenExpression.ToExpression(context, contextParam, out var thenType);
                return new { Expression = thenExpr, Type = thenType };
            }).ToList();
            DataTypeReference elseType = null;
            var elseValue = simpleCase.ElseExpression?.ToExpression(context, contextParam, out elseType);

            // First pass to determine final return type
            DataTypeReference type = null;

            for (var i = 0; i < simpleCase.WhenClauses.Count; i++)
            {
                var whenType = whenClauses[i].Type;

                if (!SqlTypeConverter.CanMakeConsistentTypes(valueType, whenType, context.PrimaryDataSource, out var caseType))
                    throw new NotSupportedQueryFragmentException($"Cannot compare values of type {value.Type} and {whenType}", simpleCase.WhenClauses[i].WhenExpression);

                caseTypes[i] = caseType;

                var thenType = thenClauses[i].Type;

                if (type == null)
                    type = thenType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, thenType, context.PrimaryDataSource, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", simpleCase);
            }

            if (elseValue != null)
            {
                if (type == null)
                    type = elseType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, elseType, context.PrimaryDataSource, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", simpleCase);
            }

            // Second pass to build up the calculation. Do this in reverse so we can keep wrapping the previous expression in more conditions to
            // add the earlier cases
            Expression result = null;

            if (elseValue != null)
            {
                if (!elseType.IsSameAs(type))
                    elseValue = SqlTypeConverter.Convert(elseValue, elseType, type);

                result = elseValue;
            }
            else
            {
                result = Expression.Constant(SqlTypeConverter.GetNullValue(type.ToNetType(out _)));
            }

            for (var i = simpleCase.WhenClauses.Count - 1; i >= 0; i--)
            {
                var valueCopy = value;
                var whenValue = whenClauses[i].Expression;
                var whenType = whenClauses[i].Type;
                var caseType = caseTypes[i];

                if (!valueType.IsSameAs(caseType))
                    valueCopy = SqlTypeConverter.Convert(valueCopy, valueType, caseType);

                if (!whenType.IsSameAs(caseType))
                    whenValue = SqlTypeConverter.Convert(whenValue, whenType, caseType);

                var comparison = Expression.Equal(valueCopy, whenValue);
                var returnValue = thenClauses[i].Expression;
                var returnType = thenClauses[i].Type;

                if (!returnType.IsSameAs(type))
                    returnValue = SqlTypeConverter.Convert(returnValue, returnType, type);

                result = Expression.Condition(Expression.IsTrue(comparison), returnValue, result);
            }

            sqlType = type;
            return result;
        }

        private static Expression ToExpression(this SearchedCaseExpression searchedCase, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            // Convert all the different elements to expressions
            var whenClauses = searchedCase.WhenClauses.Select(when =>
            {
                var whenExpr = when.WhenExpression.ToExpression(context, contextParam, out var whenType);
                return new { Expression = whenExpr, Type = whenType };
            }).ToList();
            var thenClauses = searchedCase.WhenClauses.Select(when =>
            {
                var thenExpr = when.ThenExpression.ToExpression(context, contextParam, out var thenType);
                return new { Expression = thenExpr, Type = thenType };
            }).ToList();
            DataTypeReference elseType = null;
            var elseValue = searchedCase.ElseExpression?.ToExpression(context, contextParam, out elseType);

            // First pass to determine final return type
            DataTypeReference type = null;

            for (var i = 0; i < thenClauses.Count; i++)
            {
                var thenType = thenClauses[i].Type;

                if (type == null)
                    type = thenType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, thenType, context.PrimaryDataSource, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", searchedCase);
            }

            if (elseValue != null)
            {
                if (type == null)
                    type = elseType;
                else if (!SqlTypeConverter.CanMakeConsistentTypes(type, elseType, context.PrimaryDataSource, out type))
                    throw new NotSupportedQueryFragmentException($"Cannot determine return type", searchedCase);
            }

            // Second pass to build up the calculation. Do this in reverse so we can keep wrapping the previous expression in more conditions to
            // add the earlier cases
            Expression result = null;

            if (elseValue != null)
            {
                if (!elseType.IsSameAs(type))
                    elseValue = SqlTypeConverter.Convert(elseValue, elseType, type);

                result = elseValue;
            }
            else
            {
                result = Expression.Constant(SqlTypeConverter.GetNullValue(type.ToNetType(out _)));
            }

            var bitType = DataTypeHelpers.Bit;

            for (var i = whenClauses.Count - 1; i >= 0; i--)
            {
                var whenValue = whenClauses[i].Expression;
                var whenType = whenClauses[i].Type;
                var returnValue = thenClauses[i].Expression;
                var returnType = thenClauses[i].Type;

                whenValue = SqlTypeConverter.Convert(whenValue, whenType, bitType);
                whenValue = Expression.IsTrue(whenValue);

                returnValue = SqlTypeConverter.Convert(returnValue, returnType, type);

                result = Expression.Condition(whenValue, returnValue, result);
            }

            sqlType = type;
            return result;
        }

        private static Expression ToExpression(this BooleanNotExpression not, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            var value = not.Expression.ToExpression(context, contextParam, out sqlType);
            return Expression.Not(value);
        }

        private static readonly Dictionary<SqlDataTypeOption, Type> _typeMapping = new Dictionary<SqlDataTypeOption, Type>
        {
            [SqlDataTypeOption.BigInt] = typeof(SqlInt64),
            [SqlDataTypeOption.Binary] = typeof(SqlBinary),
            [SqlDataTypeOption.Bit] = typeof(SqlBoolean),
            [SqlDataTypeOption.Char] = typeof(SqlString),
            [SqlDataTypeOption.Date] = typeof(SqlDate),
            [SqlDataTypeOption.DateTime] = typeof(SqlDateTime),
            [SqlDataTypeOption.DateTime2] = typeof(SqlDateTime2),
            [SqlDataTypeOption.DateTimeOffset] = typeof(SqlDateTimeOffset),
            [SqlDataTypeOption.Decimal] = typeof(SqlDecimal),
            [SqlDataTypeOption.Float] = typeof(SqlDouble),
            [SqlDataTypeOption.Image] = typeof(SqlBinary),
            [SqlDataTypeOption.Int] = typeof(SqlInt32),
            [SqlDataTypeOption.Money] = typeof(SqlMoney),
            [SqlDataTypeOption.NChar] = typeof(SqlString),
            [SqlDataTypeOption.NText] = typeof(SqlString),
            [SqlDataTypeOption.Numeric] = typeof(SqlDecimal),
            [SqlDataTypeOption.NVarChar] = typeof(SqlString),
            [SqlDataTypeOption.Real] = typeof(SqlSingle),
            [SqlDataTypeOption.SmallDateTime] = typeof(SqlDateTime),
            [SqlDataTypeOption.SmallInt] = typeof(SqlInt16),
            [SqlDataTypeOption.SmallMoney] = typeof(SqlMoney),
            [SqlDataTypeOption.Text] = typeof(SqlString),
            [SqlDataTypeOption.Time] = typeof(SqlTime),
            [SqlDataTypeOption.TinyInt] = typeof(SqlByte),
            [SqlDataTypeOption.UniqueIdentifier] = typeof(SqlGuid),
            [SqlDataTypeOption.VarBinary] = typeof(SqlBinary),
            [SqlDataTypeOption.VarChar] = typeof(SqlString),
            [SqlDataTypeOption.Sql_Variant] = typeof(SqlVariant),
        };

        /// <summary>
        /// Converts a SQL <see cref="DataTypeReference"/> to the equivalent .NET <see cref="Type"/>
        /// </summary>
        /// <param name="type">The data type to convert</param>
        /// <param name="sqlDataType">If the <paramref name="type"/> is a <see cref="SqlDataTypeReference"/>, this is set to the cast value.</param>
        /// <returns>The equivalent .NET <see cref="Type"/></returns>
        public static Type ToNetType(this DataTypeReference type, out SqlDataTypeReference sqlDataType)
        {
            if (!(type is SqlDataTypeReference dataType))
            {
                if (type.IsSameAs(DataTypeHelpers.EntityReference))
                {
                    sqlDataType = null;
                    return typeof(SqlEntityReference);
                }

                if (type.IsSameAs(DataTypeHelpers.Xml))
                {
                    sqlDataType = null;
                    return typeof(SqlXml);
                }

                throw new NotSupportedQueryFragmentException("Unsupported data type reference", type);
            }

            sqlDataType = dataType;

            if (!_typeMapping.TryGetValue(dataType.SqlDataTypeOption, out var targetType))
                throw new NotSupportedQueryFragmentException("Unknown type name", type);

            return targetType;
        }

        /// <summary>
        /// Checks if a data type is a specific SQL data type
        /// </summary>
        /// <param name="type">The data type to check</param>
        /// <param name="sqlType">The required SQL data type</param>
        /// <returns><c>true</c> if the <paramref name="type"/> is the expected <paramref name="sqlType"/>, or <c>false</c> otherwise</returns>
        public static bool IsType(this DataTypeReference type, SqlDataTypeOption sqlType)
        {
            if (!(type is SqlDataTypeReference sql))
                return false;

            return sql.SqlDataTypeOption == sqlType;
        }

        private static readonly Dictionary<Type, DataTypeReference> _netTypeMapping = new Dictionary<Type, DataTypeReference>
        {
            [typeof(SqlInt64)] = DataTypeHelpers.BigInt,
            [typeof(SqlBinary)] = DataTypeHelpers.VarBinary(Int32.MaxValue),
            [typeof(SqlBoolean)] = DataTypeHelpers.Bit,
            [typeof(SqlDateTime)] = DataTypeHelpers.DateTime,
            [typeof(SqlDecimal)] = DataTypeHelpers.Decimal(38, 10),
            [typeof(SqlDouble)] = DataTypeHelpers.Float,
            [typeof(SqlInt32)] = DataTypeHelpers.Int,
            [typeof(SqlMoney)] = DataTypeHelpers.Money,
            [typeof(SqlSingle)] = DataTypeHelpers.Real,
            [typeof(SqlInt16)] = DataTypeHelpers.SmallInt,
            [typeof(SqlByte)] = DataTypeHelpers.TinyInt,
            [typeof(SqlGuid)] = DataTypeHelpers.UniqueIdentifier,
            [typeof(SqlEntityReference)] = DataTypeHelpers.EntityReference,
            [typeof(SqlDateTime2)] = DataTypeHelpers.DateTime2(7),
            [typeof(SqlDateTimeOffset)] = DataTypeHelpers.DateTimeOffset,
            [typeof(SqlDate)] = DataTypeHelpers.Date,
            [typeof(SqlTime)] = DataTypeHelpers.Time(7),
            [typeof(SqlXml)] = DataTypeHelpers.Xml,
            [typeof(SqlVariant)] = DataTypeHelpers.Variant,
        };

        /// <summary>
        /// Converts a .NET <see cref="Type"/> to the equivalent SQL <see cref="DataTypeReference"/>
        /// </summary>
        /// <param name="type">The data type to convert</param>
        /// <returns>The equivalent SQL <see cref="DataTypeReference"/></returns>
        public static DataTypeReference ToSqlType(this Type type, DataSource dataSource)
        {
            if (type == typeof(SqlString))
                return DataTypeHelpers.NVarChar(Int32.MaxValue, dataSource?.DefaultCollation ?? Collation.USEnglish, dataSource?.DefaultCollation != null ? CollationLabel.Implicit : CollationLabel.CoercibleDefault);

            return _netTypeMapping[type];
        }

        private static Expression ToExpression(this ConvertCall convert, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            var value = convert.Parameter.ToExpression(context, contextParam, out var valueType);
            DataTypeReference styleType = null;
            var style = convert.Style?.ToExpression(context, contextParam, out styleType);

            sqlType = convert.DataType;

            if (sqlType is SqlDataTypeReference sqlTargetType &&
                sqlTargetType.SqlDataTypeOption.IsStringType())
            {
                // Set default length to 30
                if (sqlTargetType.Parameters.Count == 0)
                    sqlTargetType.Parameters.Add(new IntegerLiteral { Value = "30" });

                // If the input is a character string, the output string has the collation label of the input string
                // If the input is not a character string, the output string is coercible-default and assigned the collation of the current database for the connection
                var valueTypeColl = valueType as SqlDataTypeReferenceWithCollation;
                var collation = valueTypeColl?.Collation ?? context.PrimaryDataSource.DefaultCollation;
                var collationLabel = valueTypeColl?.CollationLabel ?? CollationLabel.CoercibleDefault;

                sqlType = new SqlDataTypeReferenceWithCollation
                {
                    SqlDataTypeOption = sqlTargetType.SqlDataTypeOption,
                    Parameters = { sqlTargetType.Parameters[0] },
                    Collation = collation,
                    CollationLabel = collationLabel
                };
            }

            return SqlTypeConverter.Convert(value, valueType, sqlType, style, styleType, convert);
        }

        private static Expression ToExpression(this CastCall cast, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            return ToExpression(new ConvertCall { Parameter = cast.Parameter, DataType = cast.DataType, Collation = cast.Collation }, context, contextParam, out sqlType);
        }

        private static readonly Regex _containsParser = new Regex("^\\S+( OR \\S+)*$", RegexOptions.IgnoreCase | RegexOptions.Compiled);

        private static Expression ToExpression(this FullTextPredicate fullText, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            // Only support simple CONTAINS calls to handle multi-select optionsets for now
            if (fullText.FullTextFunctionType != FullTextFunctionType.Contains)
                throw new NotSupportedQueryFragmentException("Unsupported full text predicate type", fullText) { Suggestion = "Only CONTAINS is currently supported for full text searching" };

            if (fullText.Columns.Count != 1)
                throw new NotSupportedQueryFragmentException("Only one column is currently supported for CONTAINS function", fullText);

            if (fullText.Columns[0].ColumnType == ColumnType.Wildcard)
                throw new NotSupportedQueryFragmentException("Only one column is currently supported for CONTAINS function", fullText);

            if (fullText.PropertyName != null)
                throw new NotSupportedQueryFragmentException("PROPERTY is not currently supported", fullText.PropertyName);

            if (fullText.LanguageTerm != null)
                throw new NotSupportedQueryFragmentException("LANGUAGE is not currently supported", fullText.LanguageTerm);

            var col = fullText.Columns[0].ToExpression(context, contextParam, out var colType);
            var stringType = DataTypeHelpers.NVarChar(Int32.MaxValue, context.PrimaryDataSource.DefaultCollation, CollationLabel.CoercibleDefault);

            if (!SqlTypeConverter.CanChangeTypeImplicit(colType, stringType))
                throw new NotSupportedQueryFragmentException("Only string columns are supported", fullText.Columns[0]);

            col = SqlTypeConverter.Convert(col, colType, stringType);
            sqlType = DataTypeHelpers.Bit;

            if (fullText.Value is StringLiteral lit)
            {
                if (!_containsParser.IsMatch(lit.Value))
                    throw new NotSupportedQueryFragmentException("Only simple \"word OR word OR word\" patterns are currently supported", lit);

                var words = GetContainsWords(lit.Value, true);
                return Expr.Call(() => Contains(Expr.Arg<SqlString>(), Expr.Arg<Regex[]>()), col, Expression.Constant(words));
            }

            var value = fullText.Value.ToExpression(context, contextParam, out var valueType);

            if (!SqlTypeConverter.CanChangeTypeImplicit(valueType, stringType))
                throw new NotSupportedQueryFragmentException($"Expected string value to match, got {value.Type}", fullText.Value);

            value = SqlTypeConverter.Convert(value, valueType, stringType);

            return Expr.Call(() => Contains(Expr.Arg<SqlString>(), Expr.Arg<SqlString>()), col, value);
        }

        private static SqlBoolean Contains(SqlString col, SqlString value)
        {
            if (col.IsNull || value.IsNull)
                return false;

            var words = GetContainsWords(value.Value, false);
            return Contains(col, words);
        }

        private static SqlBoolean Contains(SqlString col, Regex[] words)
        {
            if (col.IsNull)
                return false;

            return words.Any(w => w.IsMatch(col.Value));
        }

        private static Regex[] GetContainsWords(string pattern, bool compile)
        {
            if (!_containsParser.IsMatch(pattern))
                throw new QueryExecutionException("Invalid CONTAINS pattern. Only simple \"word OR word OR word\" patterns are currently supported");

            var options = RegexOptions.IgnoreCase;
            if (compile)
                options |= RegexOptions.Compiled;

            var words = pattern.ToUpperInvariant().Split(new[] { " OR " }, StringSplitOptions.None);

            return words
                .Select(w => new Regex($@"\b{Regex.Escape(w)}\b", options))
                .ToArray();
        }

        private static Expression ToExpression(this ParameterlessCall parameterless, ExpressionCompilationContext context, ParameterExpression contextParam, out DataTypeReference sqlType)
        {
            switch (parameterless.ParameterlessCallType)
            {
                case ParameterlessCallType.CurrentTimestamp:
                    sqlType = DataTypeHelpers.DateTime;
                    return Expr.Call(() => GetCurrentTimestamp(Expr.Arg<ExpressionExecutionContext>()), contextParam);

                default:
                    sqlType = DataTypeHelpers.EntityReference;
                    return Expr.Call(() => GetCurrentUser(Expr.Arg<ExpressionExecutionContext>()), contextParam);
            }
        }

        private static SqlDateTime GetCurrentTimestamp(ExpressionExecutionContext context)
        {
            if (context.Options.UseLocalTimeZone)
                return new SqlDateTime(DateTime.Now);
            else
                return new SqlDateTime(DateTime.UtcNow);
        }

        private static SqlEntityReference GetCurrentUser(ExpressionExecutionContext context)
        {
            return new SqlEntityReference(context.Options.PrimaryDataSource, "systemuser", context.Options.UserId);
        }

        /// <summary>
        /// Removes a condition from a boolean expression
        /// </summary>
        /// <param name="expr">The full boolean expression</param>
        /// <param name="remove">The condition to remove</param>
        /// <returns>A version of the <paramref name="expr"/> with the expression removed</returns>
        public static BooleanExpression RemoveCondition(this BooleanExpression expr, BooleanExpression remove)
        {
            if (expr == remove)
                return null;

            if (expr is BooleanBinaryExpression binary)
            {
                if (binary.FirstExpression == remove)
                    return binary.SecondExpression;

                if (binary.SecondExpression == remove)
                    return binary.FirstExpression;

                var clone = new BooleanBinaryExpression
                {
                    BinaryExpressionType = binary.BinaryExpressionType,
                    FirstExpression = binary.FirstExpression.RemoveCondition(remove),
                    SecondExpression = binary.SecondExpression.RemoveCondition(remove)
                };

                return clone;
            }

            if (expr is BooleanParenthesisExpression paren)
            {
                if (paren.Expression == remove)
                    return null;

                return new BooleanParenthesisExpression { Expression = paren.Expression.RemoveCondition(remove) };
            }

            return expr;
        }

        /// <summary>
        /// Gets the name of a column
        /// </summary>
        /// <param name="col">A <see cref="ColumnReferenceExpression"/></param>
        /// <returns>The name of the column being referenced</returns>
        public static string GetColumnName(this ColumnReferenceExpression col)
        {
            return String.Join(".", col.MultiPartIdentifier.Identifiers.Select(id => id.Value));
        }

        /// <summary>
        /// Gets a list of columns referenced in an expression
        /// </summary>
        /// <param name="fragment">The expression to get the list of columns from</param>
        /// <returns>A list of column names referenced in the <paramref name="fragment"/></returns>
        public static IEnumerable<string> GetColumns(this TSqlFragment fragment)
        {
            var visitor = new ColumnCollectingVisitor();
            fragment.Accept(visitor);

            return visitor.Columns
                .Where(col => col.ColumnType == ColumnType.Regular)
                .Select(col => col.GetColumnName())
                .Distinct();
        }

        /// <summary>
        /// Gets a list of variables referenced in an expression
        /// </summary>
        /// <param name="fragment">The expression to get the list of variables from</param>
        /// <returns>A list of variable names referenced in the <paramref name="fragment"/></returns>
        public static IEnumerable<string> GetVariables(this TSqlFragment fragment)
        {
            var visitor = new VariableCollectingVisitor();
            fragment.Accept(visitor);

            return visitor.Variables
                .Select(var => var.Name)
                .Distinct();
        }

        /// <summary>
        /// Parses a column name into a <see cref="ColumnReferenceExpression"/>
        /// </summary>
        /// <param name="colName">The column name to parse</param>
        /// <returns>An equivalent <see cref="ColumnReferenceExpression"/></returns>
        public static ColumnReferenceExpression ToColumnReference(this string colName)
        {
            var col = new ColumnReferenceExpression { MultiPartIdentifier = new MultiPartIdentifier() };

            foreach (var part in colName.Split('.'))
                col.MultiPartIdentifier.Identifiers.Add(new Identifier { Value = part });

            return col;
        }

        /// <summary>
        /// Checks if an expression has a constant value
        /// </summary>
        /// <param name="expr">The expression to check</param>
        /// <param name="context">The context the expression is being evaluated in</param>
        /// <param name="literal">The equivalent literal value</param>
        /// <returns><c>true</c> if the expression has a constant value, or <c>false</c> if it can change depending on the current data record</returns>
        public static bool IsConstantValueExpression(this ScalarExpression expr, ExpressionCompilationContext context, out Literal literal)
        {
            literal = expr as Literal;

            if (literal != null)
                return true;

            var columnVisitor = new ColumnCollectingVisitor();
            expr.Accept(columnVisitor);

            if (columnVisitor.Columns.Count > 0)
                return false;

            var variableVisitor = new VariableCollectingVisitor();
            expr.Accept(variableVisitor);

            if (variableVisitor.Variables.Count > 0 || variableVisitor.GlobalVariables.Count > 0)
                return false;

            var parameterlessVisitor = new ParameterlessCollectingVisitor();
            expr.Accept(parameterlessVisitor);

            if (parameterlessVisitor.ParameterlessCalls.Any(p => p.ParameterlessCallType != ParameterlessCallType.CurrentTimestamp))
                return false;

            var evaluationContext = new ExpressionExecutionContext(context);
            var value = expr.Compile(context)(evaluationContext);

            if (value == null || value is INullable n && n.IsNull)
                literal = new NullLiteral();
            else if (value is SqlInt32 i)
                literal = new IntegerLiteral { Value = i.ToString() };
            else if (value is SqlDecimal dec)
                literal = new NumericLiteral { Value = dec.ToString() };
            else if (value is SqlDouble dbl)
                literal = new NumericLiteral { Value = dbl.ToString() };
            else if (value is SqlSingle flt)
                literal = new RealLiteral { Value = flt.ToString() };
            else if (value is SqlString str)
                literal = new StringLiteral { Value = str.ToString() };
            else if (value is SqlDateTime dt)
                literal = new StringLiteral { Value = dt.Value.ToString("yyyy-MM-ddTHH:mm:ss.fff") };
            else if (value is SqlGuid g)
                literal = new StringLiteral { Value = g.ToString() };
            else
                return false;

            return true;
        }

        private static void AssertCollationSensitive(DataTypeReference sqlType, string description, TSqlFragment fragment)
        {
            if (sqlType is SqlDataTypeReferenceWithCollation collation &&
                collation.CollationLabel == CollationLabel.NoCollation)
                throw new NotSupportedQueryFragmentException($"Cannot resolve collation conflict for {description}", fragment);
        }

        /// <summary>
        /// Combines two boolean expressions with AND
        /// </summary>
        /// <param name="expr1">The first expression</param>
        /// <param name="expr2">The second expression</param>
        /// <returns>The two expressions combined with AND</returns>
        public static BooleanExpression And(this BooleanExpression expr1, BooleanExpression expr2)
        {
            if (expr1 == null)
                return expr2;

            if (expr2 == null)
                return expr1;

            return new BooleanBinaryExpression
            {
                FirstExpression = expr1,
                BinaryExpressionType = BooleanBinaryExpressionType.And,
                SecondExpression = expr2
            };
        }

        /// <summary>
        /// Returns the comparison type that can be used for the transitive comparison
        /// </summary>
        /// <param name="cmp">The comparison type to get the transitive version of</param>
        /// <returns>The transitive comparison type</returns>
        public static BooleanComparisonType TransitiveComparison(this BooleanComparisonType cmp)
        {
            switch (cmp)
            {
                case BooleanComparisonType.Equals:
                case BooleanComparisonType.NotEqualToBrackets:
                case BooleanComparisonType.NotEqualToExclamation:
                case BooleanComparisonType.IsDistinctFrom:
                case BooleanComparisonType.IsNotDistinctFrom:
                    return cmp;

                case BooleanComparisonType.LessThan:
                    return BooleanComparisonType.GreaterThanOrEqualTo;

                case BooleanComparisonType.LessThanOrEqualTo:
                case BooleanComparisonType.NotGreaterThan:
                    return BooleanComparisonType.GreaterThan;

                case BooleanComparisonType.GreaterThan:
                    return BooleanComparisonType.LessThanOrEqualTo;

                case BooleanComparisonType.GreaterThanOrEqualTo:
                case BooleanComparisonType.NotLessThan:
                    return BooleanComparisonType.LessThan;

                default:
                    throw new ArgumentOutOfRangeException(nameof(cmp));
            }
        }
    }
}
